{
  "_from": "net-snmp@^2.5.4",
  "_id": "net-snmp@2.5.4",
  "_inBundle": false,
  "_integrity": "sha512-LUhMjA+ZIi3eJLNHu/pqpnXSqTPk6JDC2nTuD9WB87FuPN0aIG7Zf610qVgcG0Hbf/NzKTfT6HTRu1UoNPhciw==",
  "_location": "/net-snmp",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "net-snmp",
    "fetchSpec": "^2.5.4",
    "name": "net-snmp",
    "raw": "net-snmp@^2.5.4",
    "rawSpec": "^2.5.4",
    "registry": true,
    "saveSpec": null,
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/net-snmp/-/net-snmp-2.5.4.tgz",
  "_shasum": "50e2cf284d35978d8e6469cb86afb0bd44b6b502",
  "_shrinkwrap": null,
  "_spec": "net-snmp@^2.5.4",
  "_where": "C:\\Users\\Connor Crosby\\Documents\\GitHub\\Comp4650-01",
  "author": {
    "email": "mark@abrahams.co.nz",
    "name": "Mark Abrahams"
  },
  "bugs": {
    "url": "https://github.com/markabrahams/node-net-snmp/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "Stephen Vickers",
      "email": "stephen.vickers@nospaceships.com"
    },
    {
      "name": "NoSpaceships Ltd",
      "email": "hello@nospaceships.com"
    },
    {
      "name": "Mark Abrahams",
      "email": "mark@abrahams.co.nz"
    }
  ],
  "dependencies": {
    "asn1-ber": "*"
  },
  "deprecated": false,
  "description": "JavaScript implementation of the Simple Network Management Protocol (SNMP)",
  "devDependencies": {
    "getopts": "*"
  },
  "directories": {
    "example": "example"
  },
  "homepage": "https://github.com/markabrahams/node-net-snmp#readme",
  "keywords": [
    "mon",
    "monitor",
    "monitoring",
    "net",
    "network",
    "snmp",
    "snmpv1",
    "snmpv2",
    "snmpv2c",
    "snmpv3"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "net-snmp",
  "optionalDependencies": {},
  "readme": "# net-snmp\n\nThis module implements versions 1, 2c and 3 of the [Simple Network Management\nProtocol (SNMP)][SNMP].\n\nThis module is installed using [node package manager (npm)][npm]:\n\n    npm install net-snmp\n\nIt is loaded using the `require()` function:\n\n    var snmp = require (\"net-snmp\");\n\nSessions to remote hosts can then be created and used to perform SNMP requests\nand send SNMP traps or informs:\n\n    var session = snmp.createSession (\"127.0.0.1\", \"public\");\n\n    var oids = [\"1.3.6.1.2.1.1.5.0\", \"1.3.6.1.2.1.1.6.0\"];\n    \n    session.get (oids, function (error, varbinds) {\n        if (error) {\n            console.error (error);\n        } else {\n            for (var i = 0; i < varbinds.length; i++)\n                if (snmp.isVarbindError (varbinds[i]))\n                    console.error (snmp.varbindError (varbinds[i]))\n                else\n                    console.log (varbinds[i].oid + \" = \" + varbinds[i].value);\n        }\n        session.close ();\n    });\n\n    session.trap (snmp.TrapType.LinkDown, function (error) {\n        if (error)\n            console.error (error);\n    });\n\n[SNMP]: http://en.wikipedia.org/wiki/Simple_Network_Management_Protocol \"SNMP\"\n[npm]: https://npmjs.org/ \"npm\"\n\n# Applications\n\nRFC 3413 describes five types of SNMP applications:\n\n 1. Command Generator Applications &mdash; which initiate read or write requests\n 2. Command Responder Applications &mdash; which respond to received read or write requests\n 3. Notification Originator Applications &mdash; which generate notifications (traps or informs)\n 4. Notification Receiver Applications &mdash; which receive notifications (traps or informs)\n 5. Proxy Forwarder Applications &mdash; which forward SNMP messages\n\nThis library provides support for all of the above applications, with the documentation\nfor each shown in this table:\n\n| Application | Common Use | Documentation |\n| ----------- | ---------- | ------------- |\n| Command Generator | NMS / SNMP tools | [Using This Module: Command & Notification Generator](#using-this-module-command--notification-generator) |\n| Command Responder | SNMP agents | [Using This Module: SNMP Agent](#using-this-module-snmp-agent) |\n| Notification Originator | SNMP agents / NMS-to-NMS notifications | [Using This Module: Command & Notification Generator](#using-this-module-command--notification-generator) |\n| Notification Receiver | NMS | [Using This Module: Notification Receiver](#using-this-module-notification-receiver) |\n| Proxy Forwarder | SNMP agents | [Forwarder Module](#forwarder-module) |\n\n# Features\n\n * Support for all SNMP versions: SNMPv1, SNMPv2c and SNMPv3\n * SNMPv3 message authentication using MD5 or SHA, and privacy using DES or AES encryption\n * Community-based and user-based authorization\n * SNMP initiator for all relevant protocol operations: Get, GetNext, GetBulk, Set, Trap, Inform\n * Convenience methods for MIB \"walking\", subtree collection, table and table column collection\n * SNMPv3 context support\n * Notification receiver for traps and informs\n * MIB parsing and MIB module store\n * SNMP agent with MIB management for both scalar and tabular data\n * Agent table index support for non-integer keys, foreign keys, composite keys and table augmentation\n * SNMP proxy forwarder for agent\n * IPv4 and IPv6\n\nNot implemented, but on the roadmap:\n * AgentX ([RFC 2741][AgentX])\n\n[AgentX]: https://tools.ietf.org/html/rfc2741 \"AgentX\"\n\n# Standards Compliance\n\nThis module aims to be fully compliant with the following RFCs:\n\n * [1155][1155] - Structure and Identification of Management Information\n * [1098][1098] - A Simple Network Management Protocol (version 1)\n * [2578][2578] - Structure of Management Information Version 2 (SMIv2)\n * [3413][3413] - Simple Network Management Protocol (SNMP) Applications\n * [3414][3414] - User-based Security Model (USM) for version 3 of the\n Simple Network Management Protocol (SNMPv3)\n * [3416][3416] - Version 2 of the Protocol Operations for the Simple\nNetwork Management Protocol (SNMP)\n * [3417][3417] - Transport Mappings for the Simple Network Management\nProtocol (SNMP)\n * [3826][3826] - The Advanced Encryption Standard (AES) Cipher Algorithm\nin the SNMP User-based Security Model\n\n[1155]: https://tools.ietf.org/rfc/rfc1155.txt \"RFC 1155\"\n[1098]: https://tools.ietf.org/rfc/rfc1098.txt \"RFC 1098\"\n[2578]: https://tools.ietf.org/rfc/rfc2578.txt \"RFC 2578\"\n[3413]: https://tools.ietf.org/rfc/rfc3413.txt \"RFC 3413\"\n[3414]: https://tools.ietf.org/rfc/rfc3414.txt \"RFC 3414\"\n[3416]: https://tools.ietf.org/rfc/rfc3416.txt \"RFC 3416\"\n[3417]: https://tools.ietf.org/rfc/rfc3417.txt \"RFC 3417\"\n[3826]: https://tools.ietf.org/rfc/rfc3826.txt \"RFC 3826\"\n\n# Constants\n\nThe following sections describe constants exported and used by this module.\n\n## snmp.Version1, snmp.Version2c, snmp.Version3\n\nThese constants are used to specify which of version supported by this module\nshould be used.\n\n## snmp.ErrorStatus\n\nThis object contains constants for all valid values the error-status field in\nresponse PDUs can hold.  If when parsing a PDU the error-index field contains\na value not defined in this object the constant `snmp.ErrorStatus.GeneralError`\nwill be used instead of the value in the error-status field.  The following\nconstants are defined in this object:\n\n * `NoError`\n * `TooBig`\n * `NoSuchName`\n * `BadValue`\n * `ReadOnly`\n * `GeneralError`\n * `NoAccess`\n * `WrongType`\n * `WrongLength`\n * `WrongEncoding`\n * `WrongValue`\n * `NoCreation`\n * `InconsistentValue`\n * `ResourceUnavailable`\n * `CommitFailed`\n * `UndoFailed`\n * `AuthorizationError`\n * `NotWritable`\n * `InconsistentName`\n\n## snmp.ObjectType\n\nThis object contains constants used to specify syntax for varbind objects,\ne.g.:\n\n    var varbind = {\n        oid: \"1.3.6.1.2.1.1.4.0\",\n        type: snmp.ObjectType.OctetString,\n        value: \"user.name@domain.name\"\n    };\n\nThe following constants are defined in this object:\n\n * `Boolean`\n * `Integer`\n * `OctetString`\n * `Null`\n * `OID`\n * `IpAddress`\n * `Counter`\n * `Gauge`\n * `TimeTicks`\n * `Opaque`\n * `Integer32`\n * `Counter32`\n * `Gauge32`\n * `Unsigned32`\n * `Counter64`\n * `NoSuchObject`\n * `NoSuchInstance`\n * `EndOfMibView`\n\n## snmp.TrapType\n\nThis object contains constants used to specify a type of SNMP trap.  These\nconstants are passed to the `trap()` and `inform()` methods exposed by the\n`Session` class.  The following constants are defined in this object:\n\n * `ColdStart`\n * `WarmStart`\n * `LinkDown`\n * `LinkUp`\n * `AuthenticationFailure`\n * `EgpNeighborLoss`\n * `EnterpriseSpecific`\n\n## snmp.PduType\n\nThis object contains constants used to identify the SNMP PDU types specified\nin RFC 3416.  The values, along with their numeric codes, are:\n\n * `160 - GetRequest`\n * `161 - GetNextRequest`\n * `162 - GetResponse`\n * `163 - SetRequest`\n * `164 - Trap`\n * `165 - GetBulkRequest`\n * `166 - InformRequest`\n * `167 - TrapV2`\n * `168 - Report`\n\n\n## snmp.SecurityLevel\n\nThis object contains constants to specify the security of an SNMPv3 message as per\nRFC 3414:\n * `noAuthNoPriv` - for no message authentication or encryption\n * `authNoPriv` - for message authentication and no encryption\n * `authPriv` - for message authentication and encryption\n\n## snmp.AuthProtocols\n\nThis object contains constants to select a supported digest algorithm for SNMPv3\nmessages that require authentication:\n * `md5` - for MD5 message authentication (HMAC-MD5-96)\n * `sha` - for SHA message authentication (HMAC-SHA-96)\n\nThese are the two hash algorithms specified in RFC 3414.  Other digest algorithms\nare not supported.\n\n## snmp.PrivProtocols\n\nThis object contains constants to select a supported encryption algorithm for\nSNMPv3 messages that require privacy:\n * `des` - for DES encryption (CBC-DES)\n * `aes` - for AES encryption (CFB-AES-128)\n\nDES is the sole encryption algorithm specified in the original SNMPv3 User-Based\nSecurity Model RFC (RFC 3414); AES for SNMPv3 was added later in RFC 3826.  Other\nencryption algorithms are not supported.\n\n# OID Strings & Varbinds\n\nSome parts of this module accept simple OID strings, e.g.:\n\n    var oid = \"1.3.6.1.2.1.1.5.0\";\n\nOther parts take an OID string, it's type and value.  This is collectively\nreferred to as a varbind, and is specified as an object, e.g.:\n\n    var varbind = {\n        oid: \"1.3.6.1.2.1.1.5.0\",\n        type: snmp.ObjectType.OctetString,\n        value: new Buffer (\"host1\")\n    };\n\nThe `type` parameter is one of the constants defined in the `snmp.ObjectType`\nobject.\n\nThe JavaScript `true` and `false` keywords are used for the values of varbinds\nwith type `Boolean`.\n\nAll integer based types are specified as expected (this includes `Integer`,\n`Counter`, `Gauge`, `TimeTicks`, `Integer32`, `Counter32`, `Gauge32`, and\n`Unsigned32`), e.g. `-128` or `100`.\n\nSince JavaScript does not offer full 64 bit integer support objects with type\n`Counter64` cannot be supported in the same way as other integer types,\ninstead [Node.js][nodejs] `Buffer` objects are used.  Users are responsible for\nproducing (i.e. for `set()` requests) and consuming (i.e. the varbinds passed\nto callback functions) `Buffer` objects.  That is, this module does not work\nwith 64 bit integers, it simply treats them as opaque `Buffer` objects.\n\nDotted decimal strings are used for the values of varbinds with type `OID`,\ne.g. `1.3.6.1.2.1.1.5.0`.\n\nDotted quad formatted strings are used for the values of varbinds with type\n`IpAddress`, e.g. `192.168.1.1`.\n\n[Node.js][nodejs] `Buffer` objects are used for the values of varbinds with\ntype `Opaque` and `OctetString`.  For varbinds with type `OctetString` this\nmodule will accept JavaScript strings, but will always give back `Buffer`\nobjects.\n\nThe `NoSuchObject`, `NoSuchInstance` and `EndOfMibView` types are used to\nindicate an error condition.  Currently there is no reason for users of this\nmodule to to build varbinds using these types.\n\n[nodejs]: http://nodejs.org \"Node.js\"\n\n# Callback Functions & Error Handling\n\nMost of the request methods exposed by this module require a mandatory\ncallback function.  This function is called once a request has been processed.\nThis could be because an error occurred when processing the request, a trap\nhas been dispatched or a successful response was received.\n\nThe first parameter to every callback is an error object.  In the case no\nerror occurred this parameter will be \"null\" indicating no error, e.g.:\n\n    function responseCb (error, varbinds) {\n        if (error) {\n            console.error (error);\n        } else {\n            // no error, do something with varbinds\n        }\n    }\n\nWhen defined, the error parameter is always an instance of the `Error` class,\nor a sub-class described in one of the sub-sections contained in this section.\n\nThe semantics of error handling is slightly different between SNMP version\n1 and subsequent versions 2c and 3.  In SNMP version 1 if an error occurs when\ncalculating the value for one OID the request as a whole will fail, i.e. no\nOIDs will have a value.\n\nThis failure manifests itself within the error-status and error-index fields\nof the response.  When the error-status field in the response is non-zero,\ni.e. not `snmp.ErrorStatus.NoError` the `callback` will be called with `error`\ndefined detailing the error.\n\nRequests made with SNMP version 1 can simply assume all OIDs have a value when\nno error object is passed to the `callback`, i.e.:\n\n    var oids = [\"1.3.6.1.2.1.1.5.0\", \"1.3.6.1.2.1.1.6.0\"];\n    \n    session.get (oids, function (error, varbinds) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            var sysName = varbinds[0].value; // this WILL have a value\n        }\n    });\n\nIn SNMP versions 2c and 3, instead of using the error-status and error-index\nfields of the response to signal an error, the value for the varbind placed in the\nresponse for an OID will have an object syntax describing an error.  The\nerror-status and error-index fields of the response will indicate the request\nwas successul, i.e. `snmp.ErrorStatus.NoError`.\n\nThis changes the way in which error checking is performed in the `callback`.\nWhen using SNMP version 2c each varbind must be checked to see if its value\nwas computed and returned successfully:\n\n    var oids = [\"1.3.6.1.2.1.1.5.0\", \"1.3.6.1.2.1.1.6.0\"];\n    \n    session.get (oids, function (error, varbinds) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            if (varbinds[0].type != snmp.ErrorStatus.NoSuchObject\n                    && varbinds[0].type != snmp.ErrorStatus.NoSuchInstance\n                    && varbinds[0].type != snmp.ErrorStatus.EndOfMibView) {\n                var sysName = varbinds[0].value;\n            } else {\n                console.error (snmp.ObjectType[varbinds[0].type] + \": \"\n                        + varbinds[0].oid);\n            }\n        }\n    });\n\nThis module exports two functions and promotes a specifc pattern to make error\nchecking a little simpler.  Firstly, regardless of version in use varbinds can\nalways be checked.  This results in a generic `callback` that can be used for\nboth versions.\n\nThe `isVarbindError()` function can be used to determine if a varbind has an\nerror condition.  This function takes a single `varbind` parameter and returns\n`true` if the varbind has an error condition, otherwise `false`.  The exported\n`varbindError()` function can then be used to obtain the error string\ndescribing the error, which will include the OID for the varbind:\n\n    session.get (oids, function (error, varbinds) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            if (snmp.isVarbindError (varbinds[0])) {\n                console.error (snmp.varbindError (varbinds[0]));\n            } else {\n                var sysName = varbinds[0].value;\n            }\n        }\n    });\n\nIf the `varbindError` function is called with a varbind for which\n`isVarbindError` would return false, the string `NotAnError` will be returned\nappended with the related OID.\n\nThe sections following defines the error classes used by this module.\n\n## snmp.RequestFailedError\n\nThis error indicates a remote host failed to process a request.  The exposed\n`message` attribute will contain a detailed error message.  This error also\nexposes a `status` attribute which contains the error-index value from a\nresponse.  This will be one of the constants defined in the\n`snmp.ErrorStatus` object.\n\n## snmp.RequestInvalidError\n\nThis error indicates a failure to render a request message before it could be\nsent.  The error can also indicate that a parameter provided was invalid.\nThe exposed `message` attribute will contain a detailed error message.\n\n## snmp.RequestTimedOutError\n\nThis error states that no response was received for a particular request.  The\nexposed `message` attribute will contain the value `Request timed out`.\n\n## snmp.ResponseInvalidError\n\nThis error indicates a failure to parse a response message.  The exposed\n`message` attribute will contain a detailed error message.\n\n# Using This Module: Command & Notification Generator\n\nThis library provides a `Session` class to provide support for building\n\"Command Generator\" and \"Notification Originator\" SNMP applications.\n\nAll SNMP requests are made using an instance of the `Session` class.  This\nmodule exports two functions that are used to create instances of the\n`Session` class:\n\n * `createSession()` - for v1 and v2c sessions\n * `createV3Session()` - for v3 sessions\n\n## snmp.createSession ([target], [community], [options])\n\nThe `createSession()` function instantiates and returns an instance of the\n`Session` class for SNMPv1 or SNMPv2c:\n\n    // Default options\n    var options = {\n        port: 161,\n        retries: 1,\n        timeout: 5000,\n        backoff: 1.0,\n        transport: \"udp4\",\n        trapPort: 162,\n        version: snmp.Version1,\n        idBitsSize: 32\n    };\n    \n    var session = snmp.createSession (\"127.0.0.1\", \"public\", options);\n\nThe optional `target` parameter defaults to `127.0.0.1`.  The optional\n`community` parameter defaults to `public`.  The optional `options` parameter\nis an object, and can contain the following items:\n\n * `port` - UDP port to send requests too, defaults to `161`\n * `retries` - Number of times to re-send a request, defaults to `1`\n * `sourceAddress` - IP address from which SNMP requests should originate,\n   there is no default for this option, the operating system will select an\n   appropriate source address when the SNMP request is sent\n * `sourcePort` - UDP port from which SNMP requests should originate, defaults\n   to an ephemeral port selected by the operation system\n * `timeout` - Number of milliseconds to wait for a response before re-trying\n   or failing, defaults to `5000`\n * `backoff` - The factor by which to increase the `timeout` for every retry, defaults to `1` for\n   no increase\n * `transport` - Specify the transport to use, can be either `udp4` or `udp6`,\n   defaults to `udp4`\n * `trapPort` - UDP port to send traps and informs too, defaults to `162`\n * `version` - Either `snmp.Version1` or `snmp.Version2c`, defaults to\n   `snmp.Version1`\n * `idBitsSize` - Either `16` or `32`, defaults to `32`.  Used to reduce the size\n    of the generated id for compatibility with some older devices.\n\nWhen a session has been finished with it should be closed:\n\n    session.close ();\n\n## snmp.createV3Session (target, user, [options])\n\nThe `createV3Session()` function instantiates and returns an instance of the\nsame `Session` class as `createSession()`, only instead initialized for SNMPv3:\n    \n    // Default options for v3\n    var options = {\n        port: 161,\n        retries: 1,\n        timeout: 5000,\n        transport: \"udp4\",\n        trapPort: 162,\n        version: snmp.Version3,\n        idBitsSize: 32,\n        context: \"\"\n    };\n\n    // Example user\n    var user = {\n        name: \"blinkybill\",\n        level: snmp.SecurityLevel.authPriv,\n        authProtocol: snmp.AuthProtocols.sha,\n        authKey: \"madeahash\",\n        privProtocol: snmp.PrivProtocols.des,\n        privKey: \"privycouncil\"\n    };\n    \n    var session = snmp.createV3Session (\"127.0.0.1\", user, options);\n\nThe `target` and `user` parameters are mandatory.  The optional `options` parameter\nhas the same meaning as for the `createSession()` call.  The one additional field\nin the options parameter is the `context` field, which adds an SNMPv3 context to\nthe session.\n\nThe `user` object must contain a `name` and `level` field.  The `level` field can\ntake these values from the `snmp.SecurityLevel` object:\n * `snmp.SecurityLevel.noAuthNoPriv` - for no message authentication or encryption\n * `snmp.SecurityLevel.authNoPriv` - for message authentication and no encryption\n * `snmp.SecurityLevel.authPriv` - for message authentication and encryption\n\nThe meaning of these are as per RFC3414.  If the `level` supplied is `authNoPriv` or\n`authPriv`, then the `authProtocol` and `authKey` fields must also be present.  The\n`authProtocol` field can take values from the `snmp.AuthProtocols` object:\n * `snmp.AuthProtocols.md5` - for MD5 message authentication\n * `snmp.AuthProtocols.sha` - for SHA message authentication\n\nIf the `level` supplied is `authPriv`, then the `privProtocol` and `privKey` fields\nmust also be present.  The `privProtocol` field can take values from the\n`snmp.PrivProtocols` object:\n * `snmp.PrivProtocols.des` - for DES encryption\n * `snmp.PrivProtocols.aes` - for AES encryption\n\nOnce a v3 session is created, the same set of `session` methods are available as\nfor v1 and v2c.\n\n## session.on (\"close\", callback)\n\nThe `close` event is emitted by the session when the sessions underlying UDP\nsocket is closed.\n\nNo arguments are passed to the callback.\n\nBefore this event is emitted all outstanding requests are cancelled, resulting\nin the failure of each outstanding request.  The error passed back through to\neach request will be an instance of the `Error` class with the errors\n`message` attribute set to `Socket forcibly closed`.\n\nThe following example prints a message to the console when a sessions\nunderlying UDP socket is closed:\n\n    session.on (\"close\", function () {\n        console.log (\"socket closed\");\n    });\n\n## session.on (\"error\", callback)\n\nThe `error` event is emitted by the session when the sessions underlying UDP\nsocket emits an error.\n\nThe following arguments will be passed to the `callback` function:\n\n * `error` - An instance of the `Error` class, the exposed `message` attribute\n   will contain a detailed error message.\n\nThe following example prints a message to the console when an error occurs\nwith a sessions underlying UDP socket, the session is then closed:\n\n    session.on (\"error\", function (error) {\n        console.log (error.toString ());\n        session.close ();\n    });\n\n## session.close ()\n\nThe `close()` method closes the sessions underlying UDP socket.  This will\nresult in the `close` event being emitted by the sessions underlying UDP\nsocket which is passed through to the session, resulting in the session also\nemitting a `close` event.\n\nThe following example closes a sessions underlying UDP socket:\n\n    session.close ();\n\n## session.get (oids, callback)\n\nThe `get()` method fetches the value for one or more OIDs.\n\nThe `oids` parameter is an array of OID strings.  The `callback` function is\ncalled once the request is complete.  The following arguments will be passed\nto the `callback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n * `varbinds` - Array of varbinds, will not be provided if an error occurred\n\nThe varbind in position N in the `varbinds` array will correspond to the OID\nin position N in the `oids` array in the request.\n\nEach varbind must be checked for an error condition using the\n`snmp.isVarbindError()` function when using SNMP version 2c.\n\nThe following example fetches values for the sysName (`1.3.6.1.2.1.1.5.0`) and\nsysLocation (`1.3.6.1.2.1.1.6.0`) OIDs:\n\n    var oids = [\"1.3.6.1.2.1.1.5.0\", \"1.3.6.1.2.1.1.6.0\"];\n    \n    session.get (oids, function (error, varbinds) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            for (var i = 0; i < varbinds.length; i++) {\n                // for version 1 we can assume all OIDs were successful\n                console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n            \n                // for version 2c we must check each OID for an error condition\n                if (snmp.isVarbindError (varbinds[i]))\n                    console.error (snmp.varbindError (varbinds[i]));\n                else\n                    console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n            }\n        }\n    });\n\n## session.getBulk (oids, [nonRepeaters], [maxRepetitions], callback)\n\nThe `getBulk()` method fetches the value for the OIDs lexicographically\nfollowing one or more OIDs in the MIB tree.\n\nThe `oids` parameter is an array of OID strings.  The optional `nonRepeaters`\nparameter specifies the number of OIDs in the `oids` parameter for which only\n1 varbind should be returned, and defaults to `0`.  For each remaining OID\nin the `oids` parameter the optional `maxRepetitions` parameter specifies how\nmany OIDs lexicographically following an OID for which varbinds should be\nfetched, and defaults to `20`.\n\nThe `callback` function is called once the request is complete.  The following\narguments will be passed to the `callback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n * `varbinds` - Array of varbinds, will not be provided if an error occurred\n\nThe varbind in position N in the `varbinds` array will correspond to the OID\nin position N in the `oids` array in the request.\n\nFor for the first `nonRepeaters` items in `varbinds` each item will be a\nsingle varbind.  For all remaining items in `varbinds` each item will be an\narray of varbinds - this makes it easy to tie response varbinds with requested\nOIDs since response varbinds are grouped and placed in the same position in\n`varbinds`.\n\nEach varbind must be checked for an error condition using the\n`snmp.isVarbindError()` function when using SNMP version 2c.\n\nThe following example fetches values for the OIDs following the sysContact\n(`1.3.6.1.2.1.1.4.0`) and sysName (`1.3.6.1.2.1.1.5.0`) OIDs, and up to the\nfirst 20 OIDs in the ifDescr (`1.3.6.1.2.1.2.2.1.2`) and ifType\n(`1.3.6.1.2.1.2.2.1.3`) columns from the ifTable (`1.3.6.1.2.1.2.2`) table:\n\n    var oids = [\n        \"1.3.6.1.2.1.1.4.0\",\n        \"1.3.6.1.2.1.1.5.0\",\n        \"1.3.6.1.2.1.2.2.1.2\",\n        \"1.3.6.1.2.1.2.2.1.3\"\n    ];\n    \n    var nonRepeaters = 2;\n    \n    session.getNext (oids, nonRepeaters, function (error, varbinds) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            // step through the non-repeaters which are single varbinds\n            for (var i = 0; i < nonRepeaters; i++) {\n                if (i >= varbinds.length)\n                    break;\n\n                if (snmp.isVarbindError (varbinds[i]))\n                    console.error (snmp.varbindError (varbinds[i]));\n                else\n                    console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n            }\n\n            // then step through the repeaters which are varbind arrays\n            for (var i = nonRepeaters; i < varbinds.length; i++) {\n                for (var j = 0; j < varbinds[i].length; j++) {\n                    if (snmp.isVarbindError (varbinds[i][j]))\n                        console.error (snmp.varbindError (varbinds[i][j]));\n                    else\n                        console.log (varbinds[i][j].oid + \"|\"\n                        \t\t+ varbinds[i][j].value);\n                }\n        }\n    });\n\n## session.getNext (oids, callback)\n\nThe `getNext()` method fetches the value for the OIDs lexicographically\nfollowing one or more OIDs in the MIB tree.\n\nThe `oids` parameter is an array of OID strings.  The `callback` function is\ncalled once the request is complete.  The following arguments will be passed\nto the `callback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n * `varbinds` - Array of varbinds, will not be provided if an error occurred\n\nThe varbind in position N in the `varbinds` array will correspond to the OID\nin position N in the `oids` array in the request.\n\nEach varbind must be checked for an error condition using the\n`snmp.isVarbindError()` function when using SNMP version 2c.\n\nThe following example fetches values for the next OIDs following the\nsysObjectID (`1.3.6.1.2.1.1.1.0`) and sysName (`1.3.6.1.2.1.1.4.0`) OIDs:\n\n    var oids = [\n        \"1.3.6.1.2.1.1.1.0\",\n        \"1.3.6.1.2.1.1.4.0\"\n    ];\n    \n    session.getNext (oids, function (error, varbinds) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            for (var i = 0; i < varbinds.length; i++) {\n                // for version 1 we can assume all OIDs were successful\n                console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n            \n                // for version 2c we must check each OID for an error condition\n                if (snmp.isVarbindError (varbinds[i]))\n                    console.error (snmp.varbindError (varbinds[i]));\n                else\n                    console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n            }\n        }\n    });\n\n## session.inform (typeOrOid, [varbinds], [options], callback)\n\nThe `inform()` method sends a SNMP inform.\n\nThe `typeOrOid` parameter can be one of two types; one of the constants\ndefined in the `snmp.TrapType` object (excluding the\n`snmp.TrapType.EnterpriseSpecific` constant), or an OID string.\n\nThe first varbind to be placed in the request message will be for the\n`sysUptime.0` OID (`1.3.6.1.6.3.1.1.4.1.0`).  The value for this varbind will\nbe the value returned by the `process.uptime ()` function multiplied by 100\n(this can be overridden by providing `upTime` in the optional `options`\nparameter, as documented below).\n\nThis will be followed by a second varbind for the `snmpTrapOID.0` OID\n(`1.3.6.1.6.3.1.1.4.1.0`).  The value for this will depend on the `typeOrOid`\nparameter. If a constant is specified the trap OID for the constant will be\nused as supplied for the varbinds value, otherwise the OID string specified\nwill be used as is for the value of the varbind.\n\nThe optional `varbinds` parameter is an array of varbinds to include in the\ninform request, and defaults to the empty array `[]`.\n\nThe optional `options` parameter is an object, and can contain the following\nitems:\n\n * `upTime` - Value of the `sysUptime.0` OID (`1.3.6.1.6.3.1.1.4.1.0`) in the\n   inform, defaults to the value returned by the `process.uptime ()` function\n   multiplied by 100\n\nThe `callback` function is called once a response to the inform request has\nbeen received, or an error occurred.  The following arguments will be passed\nto the `callback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n * `varbinds` - Array of varbinds, will not be provided if an error occurred\n\nThe varbind in position N in the `varbinds` array will correspond to the\nvarbind in position N in the `varbinds` array in the request.  The remote host\nshould echo back varbinds and their values as specified in the request, and\nthe `varbinds` array will contain each varbind as sent back by the remote host.\n\nNormally there is no reason to use the contents of the `varbinds` parameter\nsince the varbinds are as they were sent in the request.\n\nThe following example sends a generic cold-start inform to a remote host,\nit does not include any varbinds:\n\n    session.inform (snmp.TrapType.ColdStart, function (error) {\n        if (error)\n            console.error (error);\n    });\n\nThe following example sends an enterprise specific inform to a remote host,\nand includes two enterprise specific varbinds:\n\n    var informOid = \"1.3.6.1.4.1.2000.1\";\n    \n    var varbinds = [\n        {\n            oid: \"1.3.6.1.4.1.2000.2\",\n            type: snmp.ObjectType.OctetString,\n            value: \"Periodic hardware self-check\"\n        },\n        {\n            oid: \"1.3.6.1.4.1.2000.3\",\n            type: snmp.ObjectType.OctetString,\n            value: \"hardware-ok\"\n        }\n    ];\n    \n    // Override sysUpTime, specfiying it as 10 seconds...\n    var options = {upTime: 1000};\n    session.inform (informOid, varbinds, options, function (error) {\n        if (error)\n            console.error (error);\n    });\n\n## session.set (varbinds, callback)\n\nThe `set()` method sets the value of one or more OIDs.\n\nThe `varbinds` parameter is an array of varbind objects. The `callback`\nfunction is called once the request is complete.  The following arguments will\nbe passed to the `callback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n * `varbinds` - Array of varbinds, will not be provided if an error occurred\n\nThe varbind in position N in the `varbinds` array will correspond to the\nvarbind in position N in the `varbinds` array in the request.  The remote host\nshould echo back varbinds and their values as specified in the request unless\nan error occurred.  The `varbinds` array will contain each varbind as sent\nback by the remote host.\n\nEach varbind must be checked for an error condition using the\n`snmp.isVarbindError()` function when using SNMP version 2c.\n\nThe following example sets the value of the sysName (`1.3.6.1.2.1.1.4.0`) and\nsysLocation (`1.3.6.1.2.1.1.6.0`) OIDs:\n\n    var varbinds = [\n        {\n            oid: \"1.3.6.1.2.1.1.5.0\",\n            type: snmp.ObjectType.OctetString,\n            value: \"host1\"\n        }, {\n            oid: \"1.3.6.1.2.1.1.6.0\",\n            type: snmp.ObjectType.OctetString,\n            value: \"somewhere\"\n        }\n    ];\n    \n    session.set (varbinds, function (error, varbinds) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            for (var i = 0; i < varbinds.length; i++) {\n                // for version 1 we can assume all OIDs were successful\n                console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n            \n                // for version 2c we must check each OID for an error condition\n                if (snmp.isVarbindError (varbinds[i]))\n                    console.error (snmp.varbindError (varbinds[i]));\n                else\n                    console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n            }\n        }\n    });\n\n## session.subtree (oid, [maxRepetitions], feedCallback, doneCallback)\n\nThe `subtree()` method fetches the value for all OIDs lexicographically\nfollowing a specified OID in the MIB tree which have the specified OID as\ntheir base.  For example, the OIDs sysName (`1.3.6.1.2.1.1.5.0`) and\nsysLocation (`1.3.6.1.2.1.1.6.0`) both have the same base system\n(`1.3.6.1.2.1.1`) OID.\n\nFor SNMP version 1 repeated `get()` calls are made until the one of the\nreturned OIDs does not use the specified OID as its base.  For SNMP version\n2c repeated `getBulk()` calls are made until the one of the returned OIDs\ndoes no used the specified OID as its base.\n\nThe `oid` parameter is an OID string.  The optional `maxRepetitions` parameter\nis passed to `getBulk()` requests when SNMP version 2c is being used.\n\nThis method will not call a single callback once all OID values are fetched.\nInstead the `feedCallback` function will be called each time a response is\nreceived from the remote host.  The following arguments will be passed to the\n`feedCallback` function:\n\n * `varbinds` - Array of varbinds, and will contain at least one varbind\n\nEach varbind must be checked for an error condition using the\n`snmp.isVarbindError()` function when using SNMP version 2c.\n\nOnce at least one of the returned OIDs does not use the specified OID as its\nbase, or an error has occurred, the `doneCallback` function will be called.\nThe following arguments will be passed to the `doneCallback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n\nOnce the `doneCallback` function has been called the request is complete and\nthe `feedCallback` function will no longer be called.\n\nIf the `feedCallback` function returns a `true` value when called no more\n`get()` or `getBulk()` method calls will be made and the `doneCallback` will\nbe called.\n\nThe following example fetches all OIDS under the system (`1.3.6.1.2.1.1`) OID:\n\n    var oid = \"1.3.6.1.2.1.1\";\n    \n    function doneCb (error) {\n        if (error)\n            console.error (error.toString ());\n    }\n    \n    function feedCb (varbinds) {\n        for (var i = 0; i < varbinds.length; i++) {\n            if (snmp.isVarbindError (varbinds[i]))\n                console.error (snmp.varbindError (varbinds[i]));\n            else\n                console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n        }\n    }\n    \n    var maxRepetitions = 20;\n    \n    // The maxRepetitions argument is optional, and will be ignored unless using\n    // SNMP verison 2c\n    session.subtree (oid, maxRepetitions, feedCb, doneCb);\n\n## session.table (oid, [maxRepetitions], callback)\n\nThe `table()` method fetches the value for all OIDs lexicographically\nfollowing a specified OID in the MIB tree which have the specified OID as\ntheir base, much like the `subtree()` method.\n\nThis method is designed to fetch conceptial tables, for example the ifTable\n(`1.3.6.1.2.1.2.2`) table.  The values for returned varbinds will be structured\ninto objects to represent conceptual rows.  Each row is then placed into an\nobject with the rows index being the key, e.g.:\n\n    var table = {\n        // Rows keyed by ifIndex (1 and 2 are shown)\n        1: {\n            // ifDescr (column 2) and ifType (columnd 3) are shown\n            2: \"interface-1\",\n            3: 6,\n            ...\n        },\n        2: {\n            2: \"interface-2\",\n            3: 6,\n            ...\n        },\n        ...\n    }\n\nInternally this method calls the `subtree()` method to obtain the subtree of\nthe specified table.\n\nThe `oid` parameter is an OID string.  If an OID string is passed which does\nnot represent a table the resulting object produced to hold table data will be\nempty, i.e. it will contain no indexes and rows.  The optional\n`maxRepetitions` parameter is passed to the `subtree()` request.\n\nThe `callback` function will be called once the entire table has been fetched.\nThe following arguments will be passed to the `callback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n * `table` - Object containing object references representing conceptual\n   rows keyed by index (e.g. for the ifTable table rows are keyed by ifIndex),\n   each row object will contain values keyed by column number, will not be\n   provided if an error occurred\n\nIf an error occurs with any varbind returned by `subtree()` no table will be\npassed to the `callback` function.  The reason for failure, and the related\nOID string (as returned from a call to the `snmp.varbindError()` function),\nwill be passed to the `callback` function in the `error` argument as an\ninstance of the `RequestFailedError` class.\n\nThe following example fetches the ifTable (`1.3.6.1.2.1.2.2`) table:\n\n    var oid = \"1.3.6.1.2.1.2.2\";\n    \n    function sortInt (a, b) {\n        if (a > b)\n            return 1;\n        else if (b > a)\n            return -1;\n        else\n            return 0;\n    }\n    \n    function responseCb (error, table) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            // This code is purely used to print rows out in index order,\n            // ifIndex's are integers so we'll sort them numerically using\n            // the sortInt() function above\n            var indexes = [];\n            for (index in table)\n                indexes.push (parseInt (index));\n            indexes.sort (sortInt);\n            \n            // Use the sorted indexes we've calculated to walk through each\n            // row in order\n            for (var i = 0; i < indexes.length; i++) {\n                // Like indexes we sort by column, so use the same trick here,\n                // some rows may not have the same columns as other rows, so\n                // we calculate this per row\n                var columns = [];\n                for (column in table[indexes[i]])\n                    columns.push (parseInt (column));\n                columns.sort (sortInt);\n                \n                // Print index, then each column indented under the index\n                console.log (\"row for index = \" + indexes[i]);\n                for (var j = 0; j < columns.length; j++) {\n                    console.log (\"   column \" + columns[j] + \" = \"\n                            + table[indexes[i]][columns[j]]);\n                }\n            }\n        }\n    }\n    \n    var maxRepetitions = 20;\n    \n    // The maxRepetitions argument is optional, and will be ignored unless using\n    // SNMP verison 2c\n    session.table (oid, maxRepetitions, responseCb);\n\n## session.tableColumns (oid, columns, [maxRepetitions], callback)\n\nThe `tableColumns()` method implements the same interface as the `table()`\nmethod.  However, only the columns specified in the `columns` parameter will\nbe in the resulting table.\n\nThis method should be used when only selected columns are required, and\nwill be many times faster than the `table()` method since a much smaller\namount of data will be fected.\n\nThe following example fetches the ifTable (`1.3.6.1.2.1.2.2`) table, and\nspecifies that only the ifDescr (`1.3.6.1.2.1.2.2.1.2`) and ifPhysAddress\n(`1.3.6.1.2.1.2.2.1.6`) columns should actually be fetched:\n\n    var oid = \"1.3.6.1.2.1.2.2\";\n    var columns = [2, 6];\n    \n    function sortInt (a, b) {\n        if (a > b)\n            return 1;\n        else if (b > a)\n            return -1;\n        else\n            return 0;\n    }\n    \n    function responseCb (error, table) {\n        if (error) {\n            console.error (error.toString ());\n        } else {\n            // This code is purely used to print rows out in index order,\n            // ifIndex's are integers so we'll sort them numerically using\n            // the sortInt() function above\n            var indexes = [];\n            for (index in table)\n                indexes.push (parseInt (index));\n            indexes.sort (sortInt);\n            \n            // Use the sorted indexes we've calculated to walk through each\n            // row in order\n            for (var i = 0; i < indexes.length; i++) {\n                // Like indexes we sort by column, so use the same trick here,\n                // some rows may not have the same columns as other rows, so\n                // we calculate this per row\n                var columns = [];\n                for (column in table[indexes[i]])\n                    columns.push (parseInt (column));\n                columns.sort (sortInt);\n                \n                // Print index, then each column indented under the index\n                console.log (\"row for index = \" + indexes[i]);\n                for (var j = 0; j < columns.length; j++) {\n                    console.log (\"   column \" + columns[j] + \" = \"\n                            + table[indexes[i]][columns[j]]);\n                }\n            }\n        }\n    }\n    \n    var maxRepetitions = 20;\n    \n    // The maxRepetitions argument is optional, and will be ignored unless using\n    // SNMP verison 2c\n    session.tableColumns (oid, columns, maxRepetitions, responseCb);\n\n## session.trap (typeOrOid, [varbinds], [agentAddrOrOptions], callback)\n\nThe `trap()` method sends a SNMP trap.\n\nThe `typeOrOid` parameter can be one of two types; one of the constants\ndefined in the `snmp.TrapType` object (excluding the\n`snmp.TrapType.EnterpriseSpecific` constant), or an OID string.\n\nFor SNMP version 1 when a constant is specified the following fields are set in\nthe trap:\n\n * The enterprise field is set to the OID `1.3.6.1.4.1`\n * The generic-trap field is set to the constant specified\n * The specific-trap field is set to 0\n\nWhen an OID string is specified the following fields are set in the trap:\n\n * The final decimal is stripped from the OID string and set in the\n   specific-trap field\n * The remaining OID string is set in the enterprise field\n * The generic-trap field is set to the constant\n   `snmp.TrapType.EnterpriseSpecific`\n\nIn both cases the time-stamp field in the trap PDU is set to the value\nreturned by the `process.uptime ()` function multiplied by `100`.\n\nSNMP version 2c messages are quite different in comparison with version 1.\nThe version 2c trap has a much simpler format, simply a sequence of varbinds.\nThe first varbind to be placed in the trap message will be for the\n`sysUptime.0` OID (`1.3.6.1.6.3.1.1.4.1.0`).  The value for this varbind will\nbe the value returned by the `process.uptime ()` function multiplied by 100\n(this can be overridden by providing `upTime` in the optional `options`\nparameter, as documented below).\n\nThis will be followed by a second varbind for the `snmpTrapOID.0` OID\n(`1.3.6.1.6.3.1.1.4.1.0`).  The value for this will depend on the `typeOrOid`\nparameter.  If a constant is specified the trap OID for the constant\nwill be used as supplied for the varbinds value, otherwise the OID string\nspecified will be used as is for the value of the varbind.\n\nThe optional `varbinds` parameter is an array of varbinds to include in the\ntrap, and defaults to the empty array `[]`.\n\nThe optional `agentAddrOrOptions` parameter can be one of two types; one is\nthe IP address used to populate the agent-addr field for SNMP version 1 type\ntraps, and defaults to `127.0.0.1`, or an object, and can contain the\nfollowing items:\n\n * `agentAddr` - IP address used to populate the agent-addr field for SNMP\n   version 1 type traps, and defaults to `127.0.0.1`\n * `upTime` - Value of the `sysUptime.0` OID (`1.3.6.1.6.3.1.1.4.1.0`) in the\n   trap, defaults to the value returned by the `process.uptime ()` function\n   multiplied by 100\n\n**NOTE** When using SNMP version 2c the `agentAddr` parameter is ignored if\nspecified since version 2c trap messages do not have an agent-addr field.\n\nThe `callback` function is called once the trap has been sent, or an error\noccurred.  The following arguments will be passed to the `callback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n\nThe following example sends an enterprise specific trap to a remote host using\na SNMP version 1 trap, and includes the sysName (`1.3.6.1.2.1.1.5.0`) varbind\nin the trap.  Before the trap is sent the `agentAddr` field is calculated using\nDNS to resolve the hostname of the local host:\n\n    var enterpriseOid = \"1.3.6.1.4.1.2000.1\"; // made up, but it may be valid\n    \n    var varbinds = [\n        {\n            oid: \"1.3.6.1.2.1.1.5.0\",\n            type: snmp.ObjectType.OctetString,\n            value: \"host1\"\n        }\n    ];\n    \n    dns.lookup (os.hostname (), function (error, agentAddress) {\n        if (error) {\n            console.error (error);\n        } else {\n            // Override sysUpTime, specfiying it as 10 seconds...\n            var options = {agentAddr: agentAddress, upTime: 1000};\n            session.trap (enterpriseOid, varbinds, agentAddress,\n                    function (error) {\n                if (error)\n                    console.error (error);\n            });\n        }\n    });\n\nThe following example sends a generic link-down trap to a remote host using a\nSNMP version 1 trap, it does not include any varbinds or specify the\n`agentAddr` parameter:\n\n    session.trap (snmp.TrapType.LinkDown, function (error) {\n        if (error)\n            console.error (error);\n    });\n\nThe following example sends an enterprise specific trap to a remote host using\na SNMP version 2c trap, and includes two enterprise specific varbinds:\n\n    var trapOid = \"1.3.6.1.4.1.2000.1\";\n    \n    var varbinds = [\n        {\n            oid: \"1.3.6.1.4.1.2000.2\",\n            type: snmp.ObjectType.OctetString,\n            value: \"Hardware health status changed\"\n        },\n        {\n            oid: \"1.3.6.1.4.1.2000.3\",\n            type: snmp.ObjectType.OctetString,\n            value: \"status-error\"\n        }\n    ];\n    \n    // version 2c should have been specified when creating the session\n    session.trap (trapOid, varbinds, function (error) {\n        if (error)\n            console.error (error);\n    });\n\n## session.walk (oid, [maxRepetitions], feedCallback, doneCallback)\n\nThe `walk()` method fetches the value for all OIDs lexicographically following\na specified OID in the MIB tree.\n\nFor SNMP version 1 repeated `get()` calls are made until the end of the MIB\ntree is reached.  For SNMP version 2c repeated `getBulk()` calls are made\nuntil the end of the MIB tree is reached.\n\nThe `oid` parameter is an OID string.  The optional `maxRepetitions` parameter\nis passed to `getBulk()` requests when SNMP version 2c is being used.\n\nThis method will not call a single callback once all OID values are fetched.\nInstead the `feedCallback` function will be called each time a response is\nreceived from the remote host.  The following arguments will be passed to the\n`feedCallback` function:\n\n * `varbinds` - Array of varbinds, and will contain at least one varbind\n\nEach varbind must be checked for an error condition using the\n`snmp.isVarbindError()` function when using SNMP version 2c.\n\nOnce the end of the MIB tree has been reached, or an error has occurred, the\n`doneCallback` function will be called.  The following arguments will be\npassed to the `doneCallback` function:\n\n * `error` - Instance of the `Error` class or a sub-class, or `null` if no\n   error occurred\n\nOnce the `doneCallback` function has been called the request is complete and\nthe `feedCallback` function will no longer be called.\n\nIf the `feedCallback` function returns a `true` value when called no more\n`get()` or `getBulk()` method calls will be made and the `doneCallback` will\nbe called.\n\nThe following example walks to the end of the MIB tree starting from the\nifTable (`1.3.6.1.2.1.2.2`) OID:\n\n    var oid = \"1.3.6.1.2.1.2.2\";\n    \n    function doneCb (error) {\n        if (error)\n            console.error (error.toString ());\n    }\n    \n    function feedCb (varbinds) {\n        for (var i = 0; i < varbinds.length; i++) {\n            if (snmp.isVarbindError (varbinds[i]))\n                console.error (snmp.varbindError (varbinds[i]));\n            else\n                console.log (varbinds[i].oid + \"|\" + varbinds[i].value);\n        }\n    }\n    \n    var maxRepetitions = 20;\n    \n    // The maxRepetitions argument is optional, and will be ignored unless using\n    // SNMP verison 2c\n    session.walk (oid, maxRepetitions, feedCb, doneCb);\n\n# Using This Module: Notification Receiver\n\nRFC 3413 classifies a \"Notification Receiver\" SNMP application that receives\n\"Notification-Class\" PDUs. Notifications include both SNMP traps and informs.\nThis library is able to receive all types of notification PDU:\n\n * `Trap-PDU` (original v1 trap PDUs, which are now considered obselete)\n * `Trapv2-PDU` (unacknowledged notifications)\n * `InformRequest-PDU` (same format as `Trapv2-PDU` but with message acknowledgement)\n\nThe library provides a `Receiver` class for receiving SNMP notifications. This\nmodule exports the `createReceiver()` function, which creates a new `Receiver`\ninstance.\n\nThe receiver creates an `Authorizer` instance to control incoming access.  More\ndetail on this is found below in the [Authorizer Module](#authorizer-module) section\nbelow.\n\n## snmp.createReceiver (options, callback)\n\nThe `createReceiver()` function instantiates and returns an instance of the `Receiver`\nclass:\n\n    // Default options\n    var options = {\n        port: 162,\n        disableAuthorization: false,\n        engineID: \"8000B98380XXXXXXXXXXXX\", // where the X's are random hex digits\n        transport: \"udp4\"\n    };\n\n    var callback = function (error, notification) {\n        if ( error ) {\n            console.error (error);\n        } else {\n            console.log (JSON.stringify(notification, null, 2));\n        }\n    };\n\n    receiver = snmp.createReceiver (options, callback);\n\nNote that binding to the default port (162) on some systems requires the receiver process\nto be run with administrative privilege.  If this is not possible\n\nThe `options` and `callback` parameters are mandatory.  The `options` parameter is\nan object, possibly empty, and can contain the following fields:\n\n * `port` - the port to listen for notifications on - defaults to 162.  Note that binding to\n port 162 on some systems requires the receiver process to be run with administrative\n privilege.  If this is not possible then choose a port greater than 1024.\n * `disableAuthorization` - disables local authorization for all community-based\n notifications received and for those user-based notifications received with no\n message authentication or privacy (noAuthNoPriv) - defaults to false\n * `engineID` - the engineID used for SNMPv3 communications, given as a hex string -\n defaults to a system-generated engineID containing elements of random\n * `transport` - the transport family to use - defaults to `udp4`\n\nThe `callback` parameter is a callback function of the form\n`function (error, notification)`.  On an error condition, the `notification`\nparameter is set to `null`.  On successful reception of a notification, the error\nparameter is set to `null`, and the `notification` parameter is set as an object\nwith the notification PDU details in the `pdu` field and the sender socket details\nin the `rinfo` field.  For example:\n\n    {\n        \"pdu\": {\n            \"type\": 166,\n            \"id\": 45385686,\n            \"varbinds\": [\n                {\n                    \"oid\": \"1.3.6.1.2.1.1.3.0\",\n                    \"type\": 67,\n                    \"value\": 5\n                },\n                {\n                    \"oid\": \"1.3.6.1.6.3.1.1.4.1.0\",\n                    \"type\": 6,\n                    \"value\": \"1.3.6.1.6.3.1.1.5.2\"\n                }\n            ],\n            \"scoped\": false\n        },\n        \"rinfo\": {\n            \"address\": \"127.0.0.1\",\n            \"family\": \"IPv4\",\n            \"port\": 43162,\n            \"size\": 72\n        }\n    }\n\n## receiver.getAuthorizer ()\n\nReturns the receiver's `Authorizer` instance, used to control access\nto the receiver.  See the `Authorizer` section for further details.\n\n## receiver.close ()\n\nCloses the receiver's listening socket, ending the operation of the receiver.\n\n# Using This Module: SNMP Agent\n\nThe SNMP agent responds to all four \"request class\" PDUs relevant to a Command Responder\napplication:\n\n * **GetRequest** - request exactly matched OID instances\n * **GetNextRequest** - request lexicographically \"next\" OID instances in the MIB tree\n * **GetBulkRequest** - request a series of \"next\" OID instances in the MIB tree\n * **SetRequest** - set values for specified OIDs\n\nThe agent sends a **GetResponse** PDU to all four request PDU types, in conformance to RFC 3416.\n\nThe agent - like the notification receiver - maintains an `Authorizer` instance\nto control access to the agent, details of which are in the [Authorizer Module](#authorizer-module)\nsection below.\n\nThe central data structure that the agent maintains is a `Mib` instance, the API of which is\ndetailed in the [Mib Module](#mib-module) section below.  The agent allows the MIB to be queried\nand manipulated through the API, as well as queried and manipulated through the SNMP interface with\nthe above four request-class PDUs.\n\nThe agent also supports SNMP proxy forwarder applications with its singleton `Forwarder` instance,\nwhich is documented in the [Forwarder Module](#forwarder-module) section below.\n\n## snmp.createAgent (options, callback)\n\nThe `createAgent()` function instantiates and returns an instance of the `Agent`\nclass:\n\n    // Default options\n    var options = {\n        port: 161,\n        disableAuthorization: false,\n        engineID: \"8000B98380XXXXXXXXXXXX\", // where the X's are random hex digits\n        transport: \"udp4\"\n    };\n\n    var callback = function (error, data) {\n        if ( error ) {\n            console.error (error);\n        } else {\n            console.log (JSON.stringify(data, null, 2));\n        }\n    };\n\n    agent = snmp.createAgent (options, callback);\n\nThe `options` and `callback` parameters are mandatory.  The `options` parameter is\nan object, possibly empty, and can contain the following fields:\n\n * `port` - the port for the agent to listen on - defaults to 161.  Note that\n binding to port 161 on some systems requires the receiver processto be run with\n administrative privilege.  If this is not possible, then choose a port greater\n than 1024.\n * `disableAuthorization` - disables local authorization for all community-based\n notifications received and for those user-based notifications received with no\n message authentication or privacy (noAuthNoPriv) - defaults to false\n * `engineID` - the engineID used for SNMPv3 communications, given as a hex string -\n defaults to a system-generated engineID containing elements of random\n * `transport` - the transport family to use - defaults to `udp4`\n\n## agent.getAuthorizer ()\n\nReturns the agent's singleton `Authorizer` instance, used to control access\nto the agent.  See the `Authorizer` section for further details.\n\n## agent.getMib ()\n\nReturns the agent's singleton `Mib` instance, which holds all of the management data\nfor the agent.\n\n## agent.getForwarder ()\n\nReturns the agent's singleton `Forwarder` instance, which holds a list of registered\nproxies that specify context-based forwarding to remote hosts.\n\n## agent.close ()\n\nCloses the receiver's listening socket, ending the operation of the receiver.\n\n# Authorizer Module\n\nBoth the receiver and agent maintain an singleton `Authorizer` instance, which is\nresponsible for maintaining an authorization list of SNMP communities (for v1 and\nv2c notifications) and also an authorization list of SNMP users (for v3 notifications).\nThese lists are used to authorize notification access to the receiver, and to store\nsecurity protocol and key settings.  RFC 3414 terms the user list as the the\n\"usmUserTable\" stored in the receiver's \"Local Configuration Database\".\n\nIf a v1 or v2c notification is received with a community that is not in the\nreceiver's community authorization list, the receiver will not accept the notification,\ninstead returning a error of class `RequestFailedError` to the supplied callback\nfunction.  Similarly, if a v3 notification is received with a user whose name is\nnot in the receiver's user authorization list, the receiver will return a\n`RequestFailedError`.  If the `disableAuthorization` option is supplied for the\nreceiver on start-up, then these local authorization list checks are disabled for\ncommunity notifications and noAuthNoPriv user notifications.  Note that even with\nthis setting, the user list is *still checked* for authNoPriv and authPriv notifications,\nas the library still requires access to the correct keys for the message authentication\nand encryption operations, and these keys are stored against a user in the user\nauthorization list.\n\nThe API allows the receiver's community authorization and user authorization lists\nto be managed with adds, queries and deletes.\n\nThe authorizer instance can be obtained by using the `getAuthorizer()`\ncall, for both the receiver and the agent.  For example:\n\n    receiver.getAuthorizer() .getCommunities();\n\n## authorizer.addCommunity (community)\n\nAdds a community string to the receiver's community authorization list.  Does\nnothing if the community is already in the list, ensuring there is only one\noccurence of any given community string in the list.\n\n## authorizer.getCommunity (community)\n\nReturns a community string if it is stored in the receiver's community authorization\nlist, otherwise returns `null`.\n\n## authorizer.getCommunities ()\n\nReturns the receiver's community authorization list.\n\n## authorizer.deleteCommunity (community)\n\nDeletes a community string from the receiver's community authorization list.  Does\nnothing if the community is not in the list.\n\n## authorizer.addUser (user)\n\nAdds a user to the receiver's user authorization list.  If a user of the same name\nis in the list, this call deletes the existing user, and replaces it with the supplied\nuser, ensuring that only one user with a given name will exist in the list.  The user\nobject is in the same format as that used for the `session.createV3Session()` call.\n\n    var user = {\n        name: \"elsa\"\n        level: snmp.SecurityLevel.authPriv,\n        authProtocol: snmp.AuthProtocols.sha,\n        authKey: \"imlettingitgo\",\n        privProtocol: snmp.PrivProtocols.des,\n        privKey: \"intotheunknown\"\n    };\n\n    receiver.getAuthorizer ().addUser (elsa);\n\n## authorizer.getUser (userName)\n\nReturns a user object if a user with the supplied name is stored in the receiver's\nuser authorization list, otherwise returns `null`.\n\n## authorizer.getUsers ()\n\nReturns the receiver's user authorization list.\n\n## authorizer.deleteUser (userName)\n\nDeletes a user from the receiver's user authorization list.  Does nothing if the user\nwith the supplied name is not in the list.\n\n# Mib Module\n\nAn `Agent` instance, when created, in turn creates an instance of the `Mib` class.  There\nis no direct API call to create a `Mib` instance; this creation is the responsibility of\nthe agent.  An agent always has one and only one `Mib` instance.  The agent's `Mib`\ninstance is accessed through the `agent.getMib ()` call.\n\nThe MIB is a tree structure that holds management information.  Information is \"addressed\"\nin the tree by a series of integers, which form an Object ID (OID) from the root of the\ntree down.\n\nThere are only two kinds of data structures that hold data in a MIB:\n\n * **scalar** data - the scalar variable is stored at a node in the MIB tree, and\n the value of the variable is a single child node of the scalar variable node, always with\n address \"0\".  For example, the sysDescr scalar variable is located at \"1.3.6.1.2.1.1.1\".\n The value of the sysDescr variable is stored at \"1.3.6.1.2.1.1.1.0\"\n\n    ```\n    1.3.6.1.2.1.1.1   <= sysDescr (scalar variable)\n    1.3.6.1.2.1.1.1.0 = OctetString: MyAwesomeHost  <= sysDescr.0 (scalar variable value)\n    ```\n\n * **table** data - the SNMP table stores data in columns and rows.  Typically, if a table\n is stored at a node in the MIB, it has an \"entry\" object addressed as \"1\" directly\n below the table OID.  Directly below the \"entry\" is a list of columns, which are typically\n numbered from \"1\" upwards.  Directly below each column are a series of rows.  In the simplest\n case a row is \"indexed\" by a single column in the table, but a row index can be a series of\n columns, or columns that give multiple integers (e.g. an IPv4 address has four integers to\n its index), or both.  Here is an example of the hierarchy of an SNMP table for part of the\n ifTable:\n\n    ```\n    1.3.6.1.2.1.2.2   <= ifTable (table)\n    1.3.6.1.2.1.2.2.1   <= ifEntry (table entry)\n    1.3.6.1.2.1.2.2.1.1   <= ifIndex (column 1)\n    1.3.6.1.2.1.2.2.1.1.1 = Integer: 1   <= ifIndex row 1 value = 1\n    1.3.6.1.2.1.2.2.1.1.2 = Integer: 2   <= ifIndex row 2 value = 2\n    ```\n\nOn creation, an `Agent` instance creates a singleton instance of the `Mib` module.  You can\nthen register a \"provider\" to the agent's `Mib` instance that gives an interface to either a scalar\ndata instance, or a table.\n\n    var myScalarProvider = {\n        name: \"sysDescr\",\n        type: snmp.MibProviderType.Scalar,\n        oid: \"1.3.6.1.2.1.1.1\",\n        scalarType: snmp.ObjectType.OctetString,\n        handler: function (mibRequest) {\n           // e.g. can update the MIB data before responding to the request here\n           mibRequest.done ();\n        }\n    };\n    var mib = agent.getMib ();\n    mib.registerProvider (myScalarProvider);\n    mib.setScalarValue (\"sysDescr\", \"MyAwesomeHost\");\n\nThis code first gives the definition of a scalar \"provider\".  A further explanation of\nthese fields is given in the `mib.registerProvider()` section.  Importantly, the `name`\nfield is the unique identifier of the provider, and is used to select the specific\nprovider in subsequent API calls.\n\nThe `registerProvider()` call adds the provider to the list of providers that the MIB holds.\nNote that this call does not add the \"oid\" node to the MIB tree.  The first call of\n`setScalarValue()` will add the instance OID \"1.3.6.1.2.1.1.1.0\" to the MIB tree,\nalong with its value.\n\nAt this point, the agent will serve up the value of this MIB node when the instance OID\n\"1.3.6.1.2.1.1.1.0\" is queried via SNMP.\n\nA table provider has a similar definition:\n\n    var myTableProvider = {\n        name: \"smallIfTable\",\n        type: snmp.MibProviderType.Table,\n        oid: \"1.3.6.1.2.1.2.2.1\",\n        tableColumns: [\n            {\n                number: 1,\n                name: \"ifIndex\",\n                type: snmp.ObjectType.Integer\n            },\n            {\n                number: 2,\n                name: \"ifDescr\",\n                type: snmp.ObjectType.OctetString\n            },\n            {\n                number: 3,\n                name: \"ifType\",\n                type: snmp.ObjectType.Integer\n            }\n        ],\n        tableIndex: [\n            {\n                columnName: \"ifIndex\"\n            }\n        ]\n    };\n    var mib = agent.getMib ();\n    mib.registerProvider (myTableProvider);\n    mib.addTableRow (\"smallIfTable\", [1, \"eth0\", 6]);\n\nHere, the provider definition takes two additions fields: `tableColumns` for the column defintions,\nand `tableIndex` for the columns used for row indexes.  In the example the `tableIndex` is the\n`ifIndex` column.  The `mib.registerProvider()` section has further details on the fields that\nmake up the provider definition.\n\nThe `oid` must be that of the \"table entry\" node, not its parent \"table\" node e.g. for\n`ifTable`, the `oid` in the provider is \"1.3.6.1.2.1.2.2.1\" (the OID for `ifEntry`).\n\nNote that there is no `handler` callback function in this particular example, so any interaction\nis directly between SNMP requests and MIB values with no other intervention.\n\n\n## mib.registerProvider (definition)\n\nRegisters a provider definition with the MIB.  Doesn't add anything to the MIB tree.\n\nA provider definition has these fields:\n\n * `name`  *(mandatory)* - the name of the provider, which serves as a unique key to reference the\n provider for getting and setting values\n * `type`  *(mandatory)* - must be either `snmp.MibProviderType.Scalar` or `snmp.MibProviderType.Table`\n (mandatory)\n * `oid`  *(mandatory)* - the OID where the provider is registered in the MIB tree.  Note that this\n is **not** the \"instance node\" (the \".0\" node), but the one above it.  In this case, the\n provider registers at \"1.3.6.1.2.1.1.1\", to provide the value at \"1.3.6.1.2.1.1.1.0\".\n * `scalarType`  *(mandatory for scalar types)* - only relevant to scalar provider type, this\n  give the type of the variable, selected from `snmp.ObjectType`\n * `tableColumns` *(mandatory for table types)* - gives any array of column definition objects for the\n table.  Each column object must have a unique `number`, a `name` and a `type` from `snmp.ObjectType`.\n * `tableIndex` *(optional for table types)* - gives an array of index entry objects used for row indexes.\n Use a single-element array for a single-column index, and multiple values for a composite index.\n An index entry object has a `columnName` field, and if the entry is in another provider's table, then\n include a `foreign` field with the name of the foreign table's provider.\n If the `tableAugments` field is absent, `tableIndex` is mandatory.\n * `tableAugments` *(optional for table types)* - gives the name of another registered provider that\n this table \"augments\".  This means that the index information is taken from the given provider's\n table, and doesn't exist in the local table's column definitions.  If the `tableIndex` field is\n absent, `tableAugments` is mandatory i.e. one of `tableIndex` and `tableAugments` needs to be\n present to define the table index.\n * `handler` *(optional)* - an optional callback function, which is called before the request to the\n MIB is made.  This could update the MIB value(s) handled by this provider.  If not given,\n the values are simply returned from (or set in) the MIB without any other processing.\n The callback function takes a `MibRequest` instance, which has a `done()` function.  This\n must be called when finished processing the request.  The `MibRequest` also has an `oid` field\n with the instance OID being operated on, and an `operation` field with the request type from\n `snmp.PduType`.\n\nAfter registering the provider with the MIB, the provider is referenced by its `name` in other API calls.\n\nWhile this call registers the provider to the MIB, it does not alter the MIB tree.\n\n## mib.registerProviders ( [definitions] )\n\nConvenience method to register an array of providers in one call.  Simply calls `registerProvider()`\nfor each provider definition in the array.\n\n## mib.unregisterProvider (name)\n\nUnregisters a provider from the MIB.  This also deletes all MIB nodes from the provider's `oid` down\nthe tree.  It will also do upstream MIB tree pruning of any interior MIB nodes that only existed for\nthe MIB tree to reach the provider `oid` node.\n\n## mib.getProviders ()\n\nReturns an object of provider definitions registered with the MIB, indexed by provider name.\n\n## mib.getProvider (name)\n\nReturns a single registered provider object for the given name.\n\n## mib.getScalarValue (scalarProviderName)\n\nRetrieves the value from a scalar provider.\n\n## mib.setScalarValue (scalarProviderName, value)\n\nSets the value for a scalar provider.  If this is the first time the scalar is set\nsince the provider has registered with the MIB, it will also add the instance (\".0\")\nnode and all requires ancestors to the MIB tree.\n\n## mib.addTableRow (tableProviderName, row)\n\nAdds a table row - in the form of an array of values - to a table provider.  If\nthe table is empty, this instantiates the provider's `oid` node and ancestors,\nits columns, before adding the row of values.  Note that the row is an array of\nelements in the order of the table columns.  If the table has any foreign index\ncolumns (i.e. those not belonging to this table), then values for these must be\nincluded the at the start of the row array, in the order they appear in the\nMIB INDEX clause.\n\n## mib.getTableColumnDefinitions (tableProviderName)\n\nReturns a list of column definition objects for the provider.\n\n## mib.getTableCells (tableProviderName, byRow, includeInstances)\n\nReturns a two-dimensional array of the table data.  If `byRow` is false (the default),\nthen the table data is given in a list of column arrays i.e. by column.  If `byRow`\nis `true`, then the data is instead a list of row arrays.  If `includeInstances` is\n`true`, then, for the column view there will be an extra first column with instance\nindex information.  If `includeInstances` is `true` for the row view, then there is\nan addition element at the start of each row with index information.\n\n## mib.getTableColumnCells (tableProviderName, columnNumber, includeInstances)\n\nReturns a single column of table data for the given column number.  If `includeInstances`\nis `true`, then two arrays are returned: the first with instance index information,\nand the second with the column data.\n\n## mib.getTableRowCells (tableProviderName, rowIndex)\n\nReturns a single row of table data for the given row index.  The row index is an array\nof integers built from the node immediately under the column down to the node at the end\nof the row instance, which will be a leaf node in the MIB tree.\n\n## mib.getTableSingleCell (tableProviderName, columnIndex, rowIndex)\n\nReturns a single cell value from the column and row specified.  The row index array is specified\nin the same way as for the `getTableRowCells()` call.\n\n## mib.setTableSingleCell (tableProviderName, columnIndex, rowIndex, value)\n\nSets a single cell value at the column and row specified.  The row index array is specified\nin the same way as for the `getTableRowCells()` call.\n\n## mib.deleteTableRow (tableProviderName, rowIndex)\n\nDeletes a table row at the row index specified.  The row index array is specified\nin the same way as for the `getTableRowCells()` call.  If this was the last row in the table,\nthe table is pruned from the MIB, although the provider still remains registered with the MIB.\nMeaning that on the addition of another row, the table will be instantiated again.\n\n## mib.dump (options)\n\nDumps the MIB in text format.  The `options` object controls the display of the dump with these\noptions fields (all are booleans that default to `true`):\n\n * `leavesOnly` - don't show interior nodes separately - only as prefix parts of leaf nodes\n (instance nodes)\n * `showProviders` - show nodes where providers are attached to the MIB\n * `showTypes` - show instance value types\n * `showValues` - show instance values\n\nFor example:\n\n    mib.dump ();\n\nproduces this sort of output:\n\n```\n1.3.6.1.2.1.1.1 [Scalar: sysDescr]\n1.3.6.1.2.1.1.1.0 = OctetString: Rage inside the machine!\n1.3.6.1.2.1.2.2.1 [Table: ifTable]\n1.3.6.1.2.1.2.2.1.1.1 = Integer: 1\n1.3.6.1.2.1.2.2.1.1.2 = Integer: 2\n1.3.6.1.2.1.2.2.1.2.1 = OctetString: lo\n1.3.6.1.2.1.2.2.1.2.2 = OctetString: eth0\n1.3.6.1.2.1.2.2.1.3.1 = Integer: 24\n1.3.6.1.2.1.2.2.1.3.2 = Integer: 6\n```\n\n# Using This Module: Module Store\n\nThe library supports MIB parsing by providing an interface to a `ModuleStore` instance into which\nyou can load MIB modules from files, and fetch the resulting JSON MIB module representations.\n\nAdditionally, once a MIB is loaded into the module store, you can produce a list of MIB \"provider\"\ndefinitions that an `Agent` can register (see the `Agent` documentation for more details), so\nthat you can start manipulating all the values defined in your MIB file right away.\n\n    // Create a module store, load a MIB module, and fetch its JSON representation\n    var store = snmp.createModuleStore ();\n    store.loadFromFile (\"/path/to/your/mibs/SNMPv2-MIB.mib\");\n    var jsonModule = store.getModule (\"SNMPv2-MIB\");\n\n    // Fetch MIB providers, create an agent, and register the providers with your agent\n    var providers = store.getProvidersForModule (\"SNMPv2-MIB\");\n    // Not recommended - but authorization and callback turned of for example brevity\n    var agent = snmp.createAgent ({disableAuthorization: true}, function (error, data) {});\n    var mib = agent.getMib ();\n    mib.registerProviders (providers);\n\n    // Start manipulating the MIB through the registered providers using the `Mib` API calls\n    mib.setScalarValue (\"sysDescr\", \"The most powerful system you can think of\");\n    mib.setScalarValue (\"sysName\", \"multiplied-by-six\");\n    mib.addTableRow (\"sysOREntry\", [1, \"1.3.6.1.4.1.47491.42.43.44.45\", \"I've dreamed up this MIB\", 20]);\n\n    // Then hit those bad boys with your favourite SNMP tools (or library ;-), e.g.\n    snmpwalk -v 2c -c public localhost 1.3.6.1\n\nMeaning you can get right to the implementation of your MIB functionality with a minimum of\nboilerplate code.\n\n## snmp.createModuleStore ()\n\nCreates a new `ModuleStore` instance, which comes pre-loaded with some \"base\" MIB modules that\nthat provide MIB definitions that other MIB modules commonly refer to (\"import\").  The list of\npre-loaded \"base\" modules is:\n\n * RFC1155-SMI\n * RFC1158-MIB\n * RFC-1212\n * RFC1213-MIB\n * SNMPv2-SMI\n * SNMPv2-CONF\n * SNMPv2-TC\n * SNMPv2-MIB\n\n## store.loadFromFile (fileName)\n\nLoads all MIB modules in the given file into the module store.  By convention, there is\ntypically only a single MIB module per file, but there can be multiple module definitions\nstored in a single file.  Loaded MIB modules are then referred to by this API by their\nMIB module name, not the source file name.  The MIB module name is the name preceding the \n`DEFINITIONS ::= BEGIN` in the MIB file, and is often the very first thing present in\na MIB file.\n\nNote that if your MIB dependends on (\"imports\") definitions from other MIB files, these must be\nloaded first e.g. the popular **IF-MIB** uses definitions from the **IANAifType-MIB**, which\ntherefore must be loaded first.  These dependencies are listed in the **IMPORTS** section of\na MIB module, usually near the top of a MIB file.  The pre-loaded \"base\" MIB modules contain\nmany of the commonly used imports.\n\n## store.getModule (moduleName)\n\nRetrieves the named MIB module from the store as a JSON object.\n\n## store.getModules (includeBase)\n\nRetrieves all MIB modules from the store.  If the `includeBase` boolean is set to true,\nthen the base MIB modules are included in the list.  The modules are returned as a single\nJSON \"object of objects\", keyed on the module name, with the values being entire JSON\nmodule represenations.\n\n## store.getModuleNames (includeBase)\n\nRetrieves a list of the names of all MIB modules loaded in the store.  If the `includeBase`\nboolean is set to true, then the base MIB modules names are included in the list.\n\n## store.getProvidersForModule (moduleName)\n\nReturns an array of `Mib` \"provider\" definitions corresponding to all scalar and table instance\nobjects contained in the named MIB module.  The list of provider definitions are then\nready to be registered to an agent's MIB by using the `agent.getMib().registerProviders()`\ncall.\n\n# Forwarder Module\n\nAn `Agent` instance, when created, in turn creates an instance of the `Forwarder` class.\nThere is no direct API call to create a `Forwarder` instance; this creation is the\nresponsibility of the agent.  An agent always has one and only one `Forwarder` instance.\nThe agent's `Forwarder` instance is accessed through the `agent.getForwarder ()` call.\n\nA `Forwader` is what RFC 3413 terms a \"Proxy Forwarder Application\".  It maintains a list\nof \"proxy\" entries, each of which configures a named SNMPv3 context name to enable access \nto a given target host with the given user credentials.  The `Forwarder` supports proxying\nof SNMPv3 sessions only.\n\n```\nvar forwarder = agent.getForwarder ();\nforwarder.addProxy({\n    context: \"slatescontext\",\n    host: \"bedrock\",\n    user: {\n        name: \"slate\",\n        level: snmp.SecurityLevel.authNoPriv,\n        authProtocol: snmp.AuthProtocols.sha,\n        authKey: \"quarryandgravel\"\n    },\n});\n```\n\nNow requests to the agent with the context \"slatescontext\" supplied will be forwarded to host \"bedrock\",\nwith the supplied credentials for user \"slate\".\n\nYou can query the proxy with a local agent user (added with the agent's `Authorizer` instance).\nAssuming your proxy runs on localhost, port 161, you could add local user \"fred\", and access the proxy\nwith the new \"fred\" user.\n\n```\nvar authorizer = agent.getAuthorizer();\nauthorizer.addUser ({\n    name: \"fred\",\n    level: snmp.SecurityLevel.noAuthNoPriv\n});\n\n// Test access using Net-SNMP tools (-n is the context option):\n\nsnmpget -v 3 -u fred -l noAuthNoPriv -n slatescontext localhost 1.3.6.1.2.1.1.1.0\n```\n\nThis proxies requests through to \"bedrock\" as per the proxy definition.\n\n## forwarder.addProxy (proxy)\n\nAdds a new proxy to the forwarder.  The proxy is an object with these fields.\n\n * `context` *(mandatory)* - the name of the SNMPv3 context for this proxy entry.  This is the unique key\n    for proxy entries i.e. there cannot be two proxies with the same context name.\n * `transport` *(optional)* - specifies the transport to use to reach the remote target.  Can be either\n    `udp4` or `udp6`, defaults to `udp4`.\n * `target` *(mandatory)* - the remote host that will receive proxied requests.\n * `port` *(optional)* - the port of the SNMP agent on the remote host.  Defaults to 161.\n * `user` *(mandatory)* - the SNMPv3 user.  The format for the user is described in the `createV3Session()`\n    call documentation.\n\n## forwarder.deleteProxy (context)\n\nDelete the proxy for the given context from the forwarder.\n\n## forwarder.getProxy (context)\n\nReturns the forwarder's proxy for the given context.\n\n## forwarder.getProxies ()\n\nReturns an object containing a list of all registered proxies, keyed by context name.\n\n## forwarder.dumpProxies ()\n\nPrints a dump of all proxy definitions to the console.\n\n\n# Example Programs\n\nExample programs are included under the module's `example` directory.\n\n# Changes\n\n## Version 1.0.0 - 14/01/2013\n\n * Initial release including only SNMP version 1 support\n\n## Version 1.1.0 - 20/01/2013\n\n * Implement SNMP version 2c support\n\n## Version 1.1.1 - 21/01/2013\n\n * Correct name used in example `require()` call to include this module\n\n## Version 1.1.2 - 22/01/2013\n\n * Implement `subtree()`, `table()` and `walk()` methods\n * Support IPv6 (added `transport` option to the `createSession()` function)\n * Re-order some methods in README.md\n\n## Version 1.1.3 - 27/01/2013\n\n * Fix some typos and grammar errors in README.md\n * Example `snmp-table` program had `snmp-subtree` in its usage message\n * Implement example `snmp-tail` program to constantly poll for an OIDs value\n * Add note to README.md about the ability to stop the `walk()` and `subtree()`\n   methods by returning `true`\n\n## Version 1.1.4 - 29/01/2013\n\n * Fix incorrect usage of the term \"NPM\" in README.md, should be \"npm\"\n\n## Version 1.1.5 - 05/02/2013\n\n * The `transport` option to `createSession()` was not used\n\n## Version 1.1.6 - 12/04/2013\n\n * Implement `tableColumns()` method\n * Added example program `snmp-table-columns.js`\n * Correct name of the `table` parameter to the `table()` callback\n * Slight OID comparison performance enhancement\n\n## Version 1.1.7 - 11/05/2013\n\n * Use MIT license instead of GPL\n\n## Version 1.1.8 - 22/06/2013\n\n * Added the example program `cisco-device-inventory.js`\n * Receive `Trap failed: TypeError: value is out of bounds` when sending\n   traps using SNMP version 2c\n\n## Version 1.1.9 - 03/11/2013\n\n * Corrected a few instances of the parameter named `requestCallback` to some\n   methods in the README.md file which should have been `feedCallback`\n * Null type is used for varbinds with a 0 value\n * Correct instances of snmp.Type to snmp.ObjectType in the README.md file\n\n## Version 1.1.10 - 01/12/2013\n\n * Error handler in the `dgram.send()` callback in the `send()` method was\n   creating a new instance of the `Error` class from the `error` parameter, but\n   it was already an instance of the `Error` class (thanks Ray Solomon)\n * Add stack traces to Error classes exported by this module (thanks Ray\n   Solomon)\n * Allow users to specify `0` retries when creating a session (thanks Ray\n   Solomon)\n * Update the list of SNMP version 1 related RFCs we adhere to in the\n   `Standards Compliance` section of the README.md file\n\n## Version 1.1.11 - 27/12/2013\n\n * Add `sourceAddress` and `sourcePort` optional options to the\n   `Session` classes `createSession()` method, which can be used to control\n   from which IP address and port messages should be sent\n * Allow users to specify sysUpTime for SNMP traps and informs\n\n## Version 1.1.12 - 02/04/2014\n\n * The `agentAddr` attribute is not used when passed in the `options` object\n   to the `trap()` method\n\n## Version 1.1.13 - 12/08/2014\n\n * Not catching error events for the UDP socket returned from the\n   `dgram.createSocket()` function\n * Some request methods do not copy arguments which results in sometimes\n   unexpected behaviour\n * Use a single UDP socket for all requests in a single SNMP session\n * Use a try/catch block in the timer callback in the `Session.send()` method\n * The `Session` can now emit an `error` event to catch errors in a sessions\n   underlying UDP socket\n * The `Session` can now emit a `close` event to catch close events from a\n   sessions underlying UDP socket, which results in the cancellation of\n   all outstanding requests\n * Added a `close()` method to `Session` to close a sessions underlying UDP\n   socket, which results a `close` event\n * Signed integers are treated as unsigned integers when parsing response\n   messages\n\n## Version 1.1.14 - 22/09/2015\n\n * Host repository on GitHub\n\n## Version 1.1.15 - 08/02/2016\n\n * When parsing an invalid response an exception in message parsing does not\n   interupt response processing\n * Incorrectly passing `req` object in call to `req.responseCb` when handling\n   errors during response processing\n\n## Version 1.1.16 - 29/02/2016\n\n * Address a number of issues detected with the Mocha test suite by a user\n\n## Version 1.1.17 - 21/03/2016\n\n * Correct reference to non-existant `req` variable in the `Session` objects\n   constructor (should be `this`)\n\n## Version 1.1.18 - 15/05/2015\n\n * Correct argument number and names to the `snmp.createSession()` function\n * Add missing braces to an example in the README.md file\n\n## Version 1.1.19 - 26/08/2016\n\n * Remove 64bit integer check to ensure a maximum of 8 bytes are given in send\n   and received messages\n\n## Version 1.2.0 - 22/07/2017\n\n * Replace asn1 dependancy with asn1-ber\n\n## Version 1.2.1 - 11/02/2018\n\n * Add support of 16bit ids to help interoperate with older devices (added the\n   `idBitsSize` option to the `createSession()` function\n * Add note to README.md that sessions should be closed when done with\n\n## Version 1.2.3 - 06/06/2018\n\n * Set NoSpaceships Ltd to be the owner and maintainer\n\n## Version 1.2.4 - 07/06/2018\n\n * Remove redundant sections from README.md\n\n## Version 2.0.0 - 16/01/2020\n\n * Add SNMPv3 support\n\n## Version 2.1.0 - 16/01/2020\n\n * Add trap and inform receiver\n\n## Version 2.1.1 - 17/01/2020\n\n * Add CONTRIBUTING.md guidelines\n\n## Version 2.1.2 - 17/01/2020\n\n * Add SNMPv3 context to Session class\n\n## Version 2.1.3 - 18/01/2020\n\n * Add IPv6 option for tests\n\n## Version 2.2.0 - 21/01/2020\n\n * Add SNMP agent\n\n## Version 2.3.0 - 22/01/2020\n\n * Add MIB parser and module store\n\n## Version 2.4.0 - 24/01/2020\n\n * Add proxy forwarder to agent\n\n## Version 2.5.0 - 25/01/2020\n\n * Add AES-128 encryption\n\n## Version 2.5.1 - 27/01/2020\n\n * Add non-integer, composite key, foreign key and augmented table index handling\n\n## Version 2.5.2 - 29/01/2020\n\n * Update CONTRIBUTING.md and parser example\n\n## Version 2.5.3 - 22/02/2020\n\n * Add backoff option\n\n## Version 2.5.4 - 22/03/2020\n\n * Fix agent crash with unexpected GetNext start OID\n\n# License\n\nCopyright (c) 2020 Mark Abrahams <mark@abrahams.co.nz>\n\nCopyright (c) 2018 NoSpaceships Ltd <hello@nospaceships.com>\n\nCopyright (c) 2013 Stephen Vickers <stephen.vickers.sv@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/markabrahams/node-net-snmp.git"
  },
  "version": "2.5.4"
}
